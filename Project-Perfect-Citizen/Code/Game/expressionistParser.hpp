//
//  expressionistParser.hpp
//  Project-Perfect-Citizen
//
//  Created by Brandon Gomez on 2/15/16.
//  Coauthored by Mark Biundo
//  Copyright Â© 2016 Hyperfocus Games. All rights reserved.
//

#ifndef expressionistParser_hpp
#define expressionistParser_hpp

#include <stdio.h>
#include <string>
#include <vector>
#include <map>

namespace expr {
    
class expressionistObj{
    ////////////////////////////////////////////////////////////////////
    ///@brief parsing out the JSON file returning a vector of the class
    ////////////////////////////////////////////////////////////////////
    friend std::vector<expressionistObj> parseExpressionist(std::string file);

	///////////////////////////////////////////////////////////////////
	/// @brief 
	/// @details Navigates an Expressionist Grammar Object through
	///  depth first traversal, assembling a string as it goes
	///  that represents that path it takes.  Checks requirements
	///  specified by markup at each stage and rules out branches that
	///  do not meet the requirements in the markup.
	/// @param[out] string A string procedurally generated by an
	///                    expressionist grammar
	/// @param[in]  vector<expressionistObj> An object containing
	///                                      an expressionist grammar
	///////////////////////////////////////////////////////////////////
	friend std::string express(const std::vector<expressionistObj>& exprObjVec);


public:
    
    ////////////////////////////////////////////////////////////////////
    ///@brief constructor for parsing expressionist data
    ////////////////////////////////////////////////////////////////////
    expressionistObj();
    
    
    
  ////////////////////////////////////////////////////////////////////
  // Setters
  ////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////
    // @brief sets the name of the object in the expressionistParser
    ////////////////////////////////////////////////////////////////////
    void setExpression(std::string expression){
        expression_ = expression;
    }
    
    ////////////////////////////////////////////////////////////////////
    // @brief sets the expression's complete.
    //     Dont know what this does yet, will ask James
    ////////////////////////////////////////////////////////////////////
    void setComplete(bool complete){
        complete_ = complete;
    }
    ////////////////////////////////////////////////////////////////////
    // @brief sets the expression's deep.
    //     Dont know what this does yet, will ask James
    ////////////////////////////////////////////////////////////////////
    void setDeep(bool deep){
        deep_ = deep;
    }
    
    ////////////////////////////////////////////////////////////////////
    // @brief sets the markup's or rules of the expression.
    //     first = expression, second.first = condition, second.second =
    //     rate. The rate of the
    //     expression, a higher rate means a higher chance of being
    //     called.
    ////////////////////////////////////////////////////////////////////
    void setMarkUp(std::map<std::string, std::pair<std::string, int>> markUp){
        markUp_ = markUp;
    }
    
  ////////////////////////////////////////////////////////////////////
  // Getters
  ////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////
    // @brief returns the name of the object in the expressionistParser
    ////////////////////////////////////////////////////////////////////
    std::string getExpression(){
        return expression_;
    }
    
    ///////////////////////////////////////////////////////////////////
    // @brief returns the expression's complete.
    //     Dont know what this does yet, will ask James
	// --true if it contains at least one rule--
    ////////////////////////////////////////////////////////////////////
    bool getComplete(){
        return complete_;
    }
    
    ////////////////////////////////////////////////////////////////////
    // @brief returns the expression's deep.
    //     Dont know what this does yet, will ask James
	//  --true if marked "deep" in editor, we use this to mark top
	//    level expansions--
    ////////////////////////////////////////////////////////////////////
    bool getDeep(){
        return deep_;
    }

    ////////////////////////////////////////////////////////////////////
    // @brief returns the markup's or rules of the expression.
    //     first = expression, second.first = condition, second.second =
    //     rate. The rate of the
    //     expression, a higher rate means a higher chance of being
    //     called.
    ////////////////////////////////////////////////////////////////////
    std::map<std::string, std::pair<std::string, int>> getMarkUp(){
        return markUp_;
    }

    
private:
    std::string expression_;
    bool complete_;
    bool deep_;
    
    std::map<std::string, std::pair<std::string, int>> markUp_;	
	

	///////////////////////////////////////////////////////////////////
	/// @brief recursive function that works with fire
	/// @details Works with fire to follow an Expressionist Grammar Obj
	/// like a tree down to its leaves, and then construct a string out
	/// of the path it took.
	/// @param
	///////////////////////////////////////////////////////////////////	
	std::string expand(const std::vector<expressionistObj>& exprObjVec);

	///////////////////////////////////////////////////////////////////
	/// @brief recursive function that works with expand
	/// @details Works with 
	/// @param[in] str A string that is being edited 
	///////////////////////////////////////////////////////////////////
	void fire(std::string& ruleName, const std::vector<expressionistObj>& exprObjVec);

};
    
};

#endif /* expressionistParser_hpp */
